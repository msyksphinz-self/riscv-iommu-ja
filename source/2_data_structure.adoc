== 2. データ構造

デバイス・コンテキスト(DC)と呼ばれるデータ構造は、デバイスとアドレス空間を関連付け、IOMMUがアドレス変換を実行するために使用するその他のデバイスごとのパラメータを保持するためにIOMMUによって使用される。
DCの場所を特定するために、 `device_id` を使用して走査されるデバイス・ディレクトリ・テーブル(DDT)と呼ばれる基数木データ構造が使用される。

デバイスが使用するアドレス空間は、デバイスの制御がゲストOSに渡される際に、第2段階のアドレス変換と保護を必要とする場合がある。
ゲストOSは、ゲストOSが制御するデバイスが使用するIOVAをGPAに変換するための第1段階のページテーブルをオプションで提供することができる。
第1段の使用が必要ない場合は、第1段のアドレス変換スキームを `Bare` に選択することで、第1段を効果的に無効にできる。
第2段階は、GPAをSPAに変換するために使用される。

デバイスの制御がハイパーバイザまたはホストOS自身によって保持されている場合、必要なアドレス変換と保護を実行するには、第1ステージだけで十分である。
第2ステージのアドレス変換スキームを `Bare` にプログラムすることによって、第2ステージのスキームをデバイスに対して効果的に無効にすることができる。

第2段アドレス変換が `Bare` でない場合、DCはルート第2段ページテーブルのPPN、仮想マシン単位でキャッシュされたアドレス変換の無効化を容易にするゲストソフトコンテキストID(GSCID)、および第2段アドレス変換スキームを保持する。

デバイスによっては、複数のプロセス・コンテキストをサポートしており、各コンテキストが異なるプロセス、したがって異なる仮想アドレス空間に関連付けられている場合がある。
このようなデバイスのコンテキストには、アドレス空間を識別する `process_id` が設定されている場合がある。
このようなデバイスは、メモリ・アクセスを行う際に、 `process_id` を `device_id` と一緒に通知して、アクセスされるアドレス空間を特定する。
このようなデバイスの例としては、複数のプロセス・コンテキストをサポートするGPUが挙げられ、各コンテキストは異なるユーザープロセスに関連付けられ、GPUはユーザープロセス自体によって提供される仮想アドレスを使用してメモリにアクセスすることができる。
`process_id` に関連付けられたアドレス空間の選択をサポートするために、DCは、プロセス・コンテキスト(PC)と呼ばれるデータ構造を見つけるために `process_id` のフィールドを使用してインデックス付けされた基数木データ構造であるルートプロセスディレクトリテーブル(PDT)のPPNを保持します。

PDTがアクティブな場合、第一段階のアドレス変換のコントロールは(PC)に保持される。

PDTがアクティブでない場合、第1段アドレス変換の制御はDC本体に保持される。

第1段アドレス変換制御には、ルート第1段ページテーブルのPPN、アドレス空間単位でキャッシュされたアドレス変換の無効化を容易にするプロセスソフトコンテキストID(PSCID)、および第1段アドレス変換スキームが含まれる。

ゲストOSが制御するデバイスからのMSIを処理するには、IOMMUはそれらのMSIをIMSIC内のゲスト割り込みファイルにリダイレクトできなければならない。
デバイスからのMSIは単なるメモリ書き込みであるため、IOMMUが他のメモリ書き込みに適用するのと同じアドレス変換が当然適用される。
しかし、IOMMUアーキテクチャは、ソフトウェアを簡素化するためと、メモリ常駐割り込みファイルをオプションでサポートするために、仮想マシンに向けたMSIを特別に扱うことができる。

この機能をサポートするために、IOMMUアーキテクチャはデバイス・コンテキストにMSIアドレスマスクとアドレスパタンを追加し、これを用いてMSIの送信先のゲスト物理アドレス空間内のページを特定する; xxx
仮想マシンに対するMSIのIOMMUサポートは、Advanced Interrupt Architecture仕様で規定されている。

DCはさらに、デバイスが生成することを許可されるトランザクションのタイプを制御する。
このような制御の一例として、デバイスがPCIeで定義されたアドレス変換サービス(ATS)[1]の使用を許可されるかどうかがある。

デバイス・コンテキスト構造には2つの形式がある：

- ベース・フォーマット: IOMMUによってSection 2.3.3で説明されるMSIの特別な処理がサポートされないときは、32バイトが使用される。
- 拡張フォーマット: サイズは64バイトであり、セクション2.3.3で規定されるMSIを変換するための追加フィールドで基本フォーマットDCを拡張する。

`capabilities.MSI_FLAT` が1の場合、拡張フォーマットが使用され、それ以外の場合はベースフォーマットが使用される。

DCを見つけるために使用されるDDTは、サポートされる `device_id` の最大幅に応じて、1レベル、2レベル、または3レベルの基数木になるように構成される。
DDT基数木を横断するためのデバイス・ディレクトリ・インデックス(DDI)を取得するための `device_id` のパーティショニングは以下の通りである：

.基本フォーマットの `device_id` パーティショニング
[wavedrom, , svg]
....
{reg: [
  {bits: 7, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 8, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

.拡張フォーマット `device_id` パーティショニング
[wavedrom, , svg]
....
{reg: [
  {bits: 6, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 9, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

PDTは、デバイスがサポートする `process_id` の最大幅に応じて、1レベル、2レベル、または3レベルの基数木になるように構成することができる。
PDTの基数木を走査するためのプロセス・ディレクトリ・インデ ックス(PDI)を得るための `process_id` の分割は以下の通りである：

.`process_id` partitioning for PDT radix-tree traversal
[wavedrom, , svg]
....
{reg: [
  {bits: 8, name: 'PDI[0]'},
  {bits: 9, name: 'PDI[1]'},
  {bits: 3, name: 'PDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

[NOTE]
====
`process_id` パーティショニングは、各プロセス・ディレクトリ・テーブルに最大4KiB(1ページ)のメモリを必要とするように設計されている。
20ビット幅の `process_id` を使用する場合、テーブルのルートは完全には入力されない。
ルート・テーブルに 32 KiB を使用させるオプションも検討されたが、これらのテーブルは実行時に割り当てられ、1 ページより大きい連続したメモリ割り当てがゲストとハイパーバイザのメモリ・アロケータにストレスを与える可能性があるため、採用されなかった。
====

[NOTE]
====
すべてのRISC-V IOMMU実装は、メインメモリにあるDDTとPDTをサポートする必要がある。
I/Oメモリ内のデータ構造をサポートすることは要求されていないが、この仕様で禁止されているわけではない。
====

=== 2.1. デバイス・ディレクトリ・テーブル（DDT）

DDTは、デバイス・ディレクトリ・インデックス（DDI）のビットを使ってインデックスを付けた1, 2, または3レベルの基数木である。
`device_id` でDCを探す。
以下の図はDDT基幹ツリーを示している。
ルート・デバイス・ディレクトリ・テーブルのPPNは、デバイス・ディレクトリ・テーブル・ポインタ（ddtp）と呼ばれるメモリ・マップド・レジスタに保持される。
各有効な非リーフ(NL)エントリは8バイトサイズで、次のデバイス・ディレクトリ・テーブルの PPN を保持する。
有効なリーフ・デバイス・ディレクトリ・テーブル・エントリはデバイス・コンテキスト(DC)を保持する。

.拡張フォーマット `DC` による3レベル、2レベル、1レベルのデバイス・ディレクトリ
image::../riscv-iommu/src/images/ddt-ext.svg[width=800,height=400, align="center"]

.基本フォーマット `DC` による3レベル、2レベル、1レベルのデバイス・ディレクトリ
image::../riscv-iommu/src/images/ddt-base.svg[width=800,height=400, align="center"]

==== 2.1.1. 非リーフDDTエントリ

有効な(`V==1`) 非リーフDDTエントリは、次のレベルのDDTのPPNを提供する。

.非リーフのデバイス・ディレクトリ・テーブル・エントリ
[wavedrom, , svg]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 9, name: 'reserved', attr: '9'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 10,  name: 'reserved', attr: '10'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== 2.1.2. リーフのDDTエントリ

リーフDDTページはDDI[0]でインデックスされ、デバイスコンテキスト（DC）を保持する。ベース・フォーマットでは DC は 32 バイトである。拡張フォーマットでは DC は 64 バイトである。

.ベースフォーマット・デバイスコンテキスト
[wavedrom, , svg]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

.拡張フォーマット・デバイス・コンテキスト
[wavedrom, , svg]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
  {bits: 64,  name: 'MSI-page-table pointer (msiptp)'},
  {bits: 64,  name: 'MSI-address-mask (msi_addr_mask)'},
  {bits: 64,  name: 'MSI-address-pattern (msi_addr_pattern)'},
  {bits: 64,  name: 'reserved'},
], config:{lanes: 8, hspace: 1024, fontsize: 16}}
....

DCは、ベースフォーマットでは4つの64ビット・ダブルワードとして、拡張フォーマットでは8つの64ビット・ダブルワードとして解釈される。
メモリ上の各ダブルワードのバイト順序は、リトルエンディアンまたはビッグエンディアンで、 `fctl.BE` （セクション5.4）で決定されるエンディアンとなる。
IOMMU は DCフィールドをどのような順序で読んでもよい。

==== 2.1.3. デバイス・コンテキスト・フィールド
===== トランスレーション・コントロール (`tc`)

.トランスレーション・コントロール (`tc`) field
[wavedrom, , svg]
....
{reg: [
  {bits: 1,  name: 'V'},
  {bits: 1,  name: 'EN_ATS'},
  {bits: 1,  name: 'EN_PRI'},
  {bits: 1,  name: 'T2GPA'},
  {bits: 1,  name: 'DTF'},
  {bits: 1,  name: 'PDTV'},
  {bits: 1,  name: 'PRPR'},
  {bits: 1,  name: 'GADE'},
  {bits: 1,  name: 'SADE'},
  {bits: 1,  name: 'DPE'},
  {bits: 1,  name: 'SBE'},
  {bits: 1,  name: 'SXL'},
  {bits: 12, name: 'reserved'},
  {bits: 8, name: 'custom'},
  {bits: 32, name: 'reserved'},
], config:{lanes: 4, hspace: 1024, fontsize: 16, fontsize: 16}}
....

Vビットが1の場合、 `DC` は有効である。
Vビットが0の場合、 `DC` の他のすべてのビットはdon't-careであり、ソフトウェアが自由に使用できる。
IOMMU が PCIe ATS 仕様[1]をサポートしている場合（capabilities レジスタを参照）、 `EN_ATS` ビットはATSトランザクション処理を有効にするために使用される。
`EN_ATS` が 1 に設定されている場合、IOMMUは以下のインバウンドトランザクションをサポートする。

* トランザクション実行のためのトランスレーションされた読み取り
* トランスレーションされた読み取りトランザクション
* トランスレーションされた書き込み/AMOトランザクション
* PCIe ATSトランスレーション・リクエスト
* PCIe ATS無効化完了メッセージ

`EN_ATS` ビットが 1 で、 `T2GPA` ビットが 1 に設定されている場合、IOMMU はデバイスからの PCIe ATS 変換要求の完了時に、提供する変換の許可とサイズを決定するために 2 段階のアドレス変換を実行する。
ただし、IOMMU はレスポンスにおいて、IOVA の変換として SPA ではなく GPA を返す。
この動作モードでは、デバイスの ATC は IOVA の変換として GPA をキャッシュし、その後の変換されたメモリ・アクセス・トランザクションのアドレスとして GPA を使用する。
通常、変換されたリクエストは SPA を使用し、IOMMU がさらに変換を実行する必要はない。
しかし、 `T2GPA` が 1 の場合、デバイスからのトランスレートされたリクエストは GPA を使用し、IOMMU によって第 2 ステージのページテーブルを使用してSPA にトランスレートされる。
`T2GPA` 制御により、デバイスが ATS 機能を誤用し、VM と関連付けられていないメモリにアクセスしようとした場合でも、ハイパーバイザはデバイスからの DMA を封じ込めることができる。

[NOTE]
====
`T2GPA` が有効な場合、PCIe ATS Translation Request に応答してデバイスに提供されるアドレスは、デバイスを他のピアデバイスやホストに接続する I/O ファブリック（PCIスイッチなど）によって直接ルーティングされない。
また、デバイス内のピアツーピアトランザクション（デバイスの機能間など）がサポートされている場合、そのようなアドレスはデバイス内でルーティングされない。

`T2GPA` を1に設定するハイパーバイザは、プロトコル固有の手段により、IOMMUがGPAを変換し、PAに基づくトランザクションをメモリまたはPAにルーティングするように、変換されたアクセスがホストを経由してルーティングされることを保証しなければならない。

ピア・デバイス。たとえばPCIeの場合、アクセス・コントロール・サービス（ACS）は、ピアツーピア（P2P）要求を常にアップストリームにリダイレクトしてホストに送るように設定する必要がある。
1 に設定された `T2GPA` の使用は、PCIe ATS 変換リクエストに応答して返される変換アドレスでタグ付けされたキャッシュを実装するデバイスと互換性がない可能性がある。
`T2GPA` を 1 に設定する代わりに、認証プロトコルがデバイスによってサポートされている場合、ハイパーバイザはデバイスとの信頼関係を確立することができる。
例えばPCIe の場合、PCIe コンポーネント測定認証（CMA）機能は、デバイスの構成とファームウェア / 実行可能ファイル（Measurement）およびハードウェアID（Authentication）を検証し、そのような信頼関係を確立するメカニズムを提供する。
====

`EN_PRI` ビットが 0 の場合、デバイスからの PCIe "Page Request" メッセージは無効なリクエストである。
デバイスから受信した "Page Request "メッセージは、"Page Request Group Response "メッセージで応答される。
通常、ソフトウェア・ハンドラがこの応答メッセージを生成する。
しかし、条件によってはIOMMU 自身が応答を生成することもある。
IOMMU が生成する「ページ要求グループ応答」メッセージでは、PRG-response-PASID-required (`PRPR`) ビットが 1 にセットされると、関連する「ページ要求」にPASID があった場合、IOMMU の応答メッセージに PASID を含める必要があることを示す。

[NOTE]
====
PASIDをサポートし、"PRG Response PASID Required "ケイパビリティビットを 1に設定している関数は、関連する "Page Request "メッセージにPASIDがあった場合、"Page Request Group Response "メッセージにPASIDが含まれることを期待する。
ケイパビリティビットが 0 の場合、関数は「ページ要求グループ応答」メッセージの PASID を期待せず、PASID を含む応答を受け取った場合の関数の動作は未定義である。
`PRPR` ビットは、「PRG Response PASID Required」ケイパビリティビットに保持されている値で構成されるべきである。
====

disable-translation-fault (`DTF`) ビットを1に設定すると、アドレス変換処理で発生したフォルトの報告が無効になる。
`DTF` を1に設定しても、フォールト・トランザクションに応答してデバイスに生成されるエラー・レスポンスは無効にならない。
`DTF` を1に設定しても、アドレス変換プロセスに関連しないIOMMUからのフォルト報告は無効にならない。
`DTF` が1のときに報告されないフォルトを表11に示す。

[NOTE]
====
ハイパーバイザーは、仮想マシンの異常終了など、エラーの多発につながる可能性がある状況を特定した場合、DTFを1に設定してフォールトレポートを無効にすることができる。
====

`DC.fsc` フィールドは、第1段翻訳用のコンテキストを保持する。
`PDTV` ビットが1の場合、このフィールドはプロセス・ディレクトリ・テーブル・ポインタ（`pdtp`）を保持する。
`PDTV` ビットが0の場合、DC.fscフィールドは(iosatp)を保持する。

`PDTV` ビットは、DCが複数のプロセス・コンテキストをサポートするデバイスに関連付けられており、その結果、そのメモリアクセスで有効な `process_id` を生成する場合に1に設定されることが期待される。
例えばPCIeの場合、リクエストにPASIDがあれば、そのPASIDが `process_id` として使われる。
`PDTV` が1のとき、 `DPE` ビットを1に設定して、有効な `process_id` がないリクエストを変換するために `process_id` のデフォルト値として0を使用できるようにすることができる。
`PDTV` が0のとき、 `DPE` ビットは将来のために予約される。

IOMMUは、 `capabilities.AMO_HWAD` が1の場合、 `GADE` および `SADE` ビットの1設定をサポートする。
`capabilities.AMO_HWAD`が0の場合、これらのビットは予約されている。

`GADE` `が1の場合、IOMMUは第2ステージのPTEのAビットとDビットをアトミックに更新する。
`GADE` が0の場合、IOMMUは、Aビットが0の場合、またはメモリアクセスがストアでDビットが0の場合に、元のアクセスタイプに対応するゲストページフォールトを引き起こす。

`SADE` が1の場合、IOMMUは第1段PTEのAビットとDビットをアトミックに更新する。
`SADE` が0の場合、IOMMUは、Aビットが0の場合、またはメモリ・アクセスがストアでDビットが0の場合に、元のアクセス・タイプに対応するページ・フォールトを引き起こす。

`SBE` が0の場合、PDTエントリーと第1ステージのPTEへの暗黙のメモリ・アクセスはリトルエンディアンである。
`SBE` がサポートする値は、 `fctl.BE` フィールドの値と同じである。

`SXL` フィールドは、表3に定義されているように、サポートされているページング仮想メモリ方式を制御する。
`fctl.GXL` が1の場合、 `SXL` フィールドは1でなければならない。そうでない場合、 `SXL` フィールドの正当な値は `fctl.GXL` フィールドの値と同じである。

`SXL` が1の場合、以下のルールが適用される:

* 第1段階が `Bare` でない場合、IOVAのビット31以降のビットが1に設定されていれば、元のアクセス種別に対応するページフォルトが発生する。
* セカンドステージが `Bare` でない場合、入力されるGPAのビット33以降のビットが1に設定されていれば、元のアクセスタイプに対応するゲストページフォールトが発生する。

===== IO ハイパーバイザーのゲストアドレス変換と保護 (`iohgatp`)

.IO ハイパーバイザーのゲストアドレス変換と保護(`iohgatp`)フィールド
[wavedrom, , svg]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'GSCID'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

`iohgatp` フィールドは、ルート・セカンドステージ・ページテーブルのPPNと、ゲスト・ソフトコンテキストID(`GSCID`)によって識別される仮想マシンを保持する。
複数のデバイスが共通の第2ステージ・ページ・テーブルを持つVMに関連付けられている場合、ハイパーバイザーはそれぞれの `iohgatp` に同じ `GSCID` をプログラムすることが期待されている。
`MODE` フィールドは、セカンドステージのアドレス変換スキームを選択するために使用される。

第2ステージのページテーブルフォーマットは、Privileged仕様で定義されている通りである。
`fctl.GXL` フィールドは、表2に定義されているように、サポートされているゲスト物理アドレスのアドレス変換スキームを制御する。
`iohgatp.MODE` フィールドは、ページングされた仮想メモリースキームを識別し、そのエンコーディングは以下の通りである：

[[IOHGATP_MODE_ENC]]
.`iohgatp.MODE` フィールドのエンコーディング
[%autowidth,float="center",align="center"]
[%header, cols="^3,^3,20"]
|===
3+^|               `fctl.GXL=0`
^|値 ^| 名前     ^| 説明
| 0    | `Bare`   | 変換も保護もない
| 1-7  | --       | 標準的な使用のために予約されている
| 8    | `Sv39x4` | ページ・ベースの41-bit 仮想アドレッシング(Sv39の2-bit拡張)
| 9    | `Sv48x4` | ページ・ベースの50-bit 仮想アドレッシング(Sv48の2-bit拡張)
| 10   | `Sv57x4` | ページ・ベースの59-bit 仮想アドレッシング(Sv57の2-bit拡張)
| 11-15| --       | 標準的な使用のために予約されている
3+^|               `fctl.GXL=1`
^|値 ^| 名前     ^| 説明
| 0    | `Bare`   | 変換も保護もない
| 1-7  | --       | 標準的な使用のために予約されている
| 8    | `Sv32x4` | ページ・ベースの34-bit 仮想アドレッシング(Sv32の2-bit拡張)
| 9-15 | --       | 標準的な使用のために予約されている
|===

実装は、 `iohgatp` 用に定義されたすべてのモード設定をサポートする必要はない。
IOMMUは、システムに統合されたHARTのMMUがサポートするモード、またはそのサブセットのみをサポートする必要がある。

`iohgatp.PPN` によって決定されるルート・ページ・テーブルは16KiBであり、16KiB境界にアライメントされなければならない。

[NOTE]
====
`iohgatp` の `GSCID` フィールドはアドレス空間を識別する。
2つのDCが参照する第2ステージのページテーブルが同一でないときに、同一の `GSCID` が2つのDCに設定された場合、IOMMUが最初のページテーブルと2番目のページテーブルのどちらのPTEを使用するかは予測できない。
これらは期待される唯一の動作である。
====

===== 変換属性(`ta`)
