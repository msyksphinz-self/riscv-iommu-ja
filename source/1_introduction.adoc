== 1. Introduction

=== 1.1. 用語集

[width="100%",cols="20%,80%",options="header",]
|===
|用語             |意味
|AIA              |RISC-V Advanced Interrupt Architecture
|ATS/PCIe ATS     |Address Translation Service: DevATCをサポートするPCIeプロトコル
|CXL              |Compute Express Linkバス仕様
|DC/Device Context|デバイスと、そのデバイスが割り当てられているVMを識別する、状態をハードウェアで表現したもの
|DDT              |Device Directory Table:デバイス・コンテキスト後続を見つけるために、一意のデバイスの識別子を使って検索する木構造
|DDI              |Device Directory Index:リーフまたはノンリーフのDT構造へのインデックスとして使用される一意のデバイス識別子のサブフィールド。
|Device ID        |DMAまたは割り込み要求の送信元を識別するための最大24ビットの識別番号。PCIeデバイスの場合は、ルーティング識別子(RID)。
|DevATC           |デバイスのアドレス変換キャッシュ
|GPA              |Guest Physical Address(ゲスト物理アドレス):仮想マシンの仮想化物理メモリ空間内のアドレス
|GSCID            |ゲストソフトコンテキストID:仮想マシンに割り当てられたデバイスの集合を一位に識別するためにソフトウェアが使用するID。IOMMUはIOATCエントリにGSCIDをつけることができる。同じGSCIDでプログラムされたデバイス・コンテキストは、同じセカンドステージページテーブルでプログラムされている必要がある。
|Guest            |仮想マシン内のソフトウェア
|HPM              |ハードウェア・パフォーマンス・モニター
|Hypervisor       |仮想化を制御するソフトウェアの実体
|ID               |識別子
|IMSIC            |Incoming Message Signal Interrupt Controller
|IOMTC            |IOMMU Address Translation Cache:アドレス変換に使われるデータ構造をキャッシュするIOMMUのキャッシュ
|IOVA             |I/Oかそうアドレス: デバイスによるDMA用の仮想アドレス
|MSI              |Message Signaled Interrupt
|OS               |Operating System
|PASID            |Process Address Space Identifier: プロセス・アドレス空間識別子:プロセスのアドレス空間を識別する。PASID値はリクエストのPASIDTLPプレフィックスで提供される。
|PBMT             |Page Base Memory Type
|PPN              |Physical Page Number
|PRI              |Page Request Interface:デバイスがOSのメモリ・マネージャにサービスを常駐させることを要求することを可能にするPCIeプロトコル。
|PC               |Program Contexit
|PCIe             |Peripheral Component Interconnect Expressバス規格
|PDI              |Process-Directory-Index:リーフまたは非リーフPDT構造体へのインデックスに使用される一位なプロセス識別子のサブフィールド
|PDT              |Process-Directory-Table:プロセス・コンテキスト構造を見つけるために一位なプロセス識別子を使って操作される基数木データ構造。
|PMA              |Physical Memory Attributes
|PMP              |Physical Memory Protection
|PPN              |Physical Page Number
|PRI              |
|Process ID       |
|PSCID            |Process soft-contexit Identifier:ソフトウェアが一位のアドレス空間を識別するために使用する識別番号。IOMMUはIOATCエントリにPSCIDをつけることができる。
|PT               |Page Table
|PTE              |Page Table Entry
|Reserved         |予約
|RID / PCIe RID   |PCIeルーティング識別子
|RO               |Read-Only
|RW               |Read-Write
|RW1C             |Write-to-1-to-Clear。1を書き込むとクリアされる。
|RW1S             |Write-to-1-to-Set。1を書き込むとセットされる
|SOC              |System On Chip
|SPA              |Supervisor Physical Address: メモリおよびメモリマップな資源にアクセスするために使用される物理アドレス
|TLP              |トランザクション層のパケット
|VA               |仮想アドレス
|VM               |仮想マシン
|VMM              |仮想マシンモニタ
|VS               |仮想スーパーバイザ。ハイパーバイザとも呼ばれる。
|WARL             |どのような値でも書き込むことができ、正当な値を読み込む。
|WPRI             |Writeした値を保持し、Readした値を無視する。
|===

== 1. Introduction

システムMMU(SMMU)と呼ばれることもある入出力メモリ管理ユニット(IOMMU)は、直接メモリ・アクセスが可能な入出力(I/O)デバイスをシステム・メモリに接続するシステム・レベルのメモリ管理ユニット(MMU)である。

IOMMUを介してシステムに接続された各I/Oデバイスに対して、IOMMUはソフトウェアを用いて**デバイス・コンテキスト**を設定することができる。デバイス・コンテキストは、デバイスに特定の仮想アドレス空間とその他のデバイスごとのパラメータを関連付ける。IOMMUで各デバイスに個別のデバイス・コンテキストを与えることで、各デバイスを個別のオペレーティングシステム(ゲスト
OS またはメイン(ホスト)OS)に個別に設定できる。デバイスがメモリ・アクセスを開始するたびに、IOMMU
は何らかの形で一意のデバイス識別子によって元のデバイスを識別する。例えば、PCIe
[1]の場合、送信デバイスは、PCIバス番号(8 ビット)、デバイス番号(5
ビット)、ファンクション番号(3 ビット)の一意の 16
ビットのtriplet(ルーティング識別子または RID と総称される)、および
IOMMU
が複数の階層をサポートする場合はオプションで最大8ビットのセグメント番号によって識別される。本仕様書では、このような一意のデバイス識別子を `device_id` と呼び、最大
24 ビット幅の識別子をサポートする。

[NOTE]
====
階層はPCI ExpressのI/O相互接続トポロジで、バス/デバイス/ファンクション番号のtoupleと呼ばれる構成空間アドレスが一意である。また、フリットモードでは、セグメント番号がファンクションのIDに含まれることがある。
====

デバイスによっては、プロセス・アドレス空間をデバイスと共有する機能である**共有仮想アドレッシング**をサポートしている場合があります。プロセス・アドレス空間をデバイスと共有することで、DMAをコア
・カーネルのメモリ管理に依存することができ、アプリケーションやデバイス・ドライバから複雑さを取り除くことができます。デバイスにバインドした後、アプリケーションは静的または動的に割り当てられ
たバッファに対してDMAを実行するよう指示できます。このようなアドレッシングをサポートするために
、ソフトウェアは1つ以上のプロセス・コンテキストをデバイス・コンテキストに設定することができます。このようなデバイスによって開始されるすべてのメモリ・アクセスには一意のプロセス識別子が付随し、IOMMUは一意のデバイス識別子と組み合わせて、ソフトウェアによってデバイス・コンテキストに
設定された適切なプロセス・コンテキストを特定するために使用します。例えば
、PCIeの場合、プロセスコンテキストは、一意の20ビットのプロセスアドレス空間識別子(PASID)によって識別される。
この仕様では、このような一意のプロセス識別子を `process_id` と呼び、最大20 ビット幅の識別子をサポートする。

IOMMUは、IOVAをSPA(Supervisor Physical
Address)に変換し、DMAのメモリ保護を実施するために、2段階のアドレス変換プロセスを採用している。アドレス変換とメモリ保護を実行するために、IOMMUはCPUのMMUが第1段階と第2段階のアドレス変換に使用するのと同じページテーブルフォーマットを使用します。CPUのMMUと同じペー
ジテーブルフォーマットを使用することで、DMAのメモリ管理の複雑さをある程度取り除くことができる
。また、同じフォーマットを使用することで、CPUのMMUとIOMMUの両方で同じページテーブルを同時に使用することができる。
2段階のアドレス変換を無効にするオプションはないが、その段階の仮想メモリスキームをベア、つまりアドレス変換もメモリ保護も行わないように設定することで、どちらかの段階を効果的に無効にすることができる。

IOMMUが採用する仮想メモリ方式は、IOMMU内のデバイスごとに個別に設定できる。デバイスは、I/O
仮想アドレス(IOVA)を使用して DMA
を実行する。デバイス用に選択された仮想メモリ方式に応じて、デバイスが使用するIOVAは、スーパーバイザ物理アドレス(SPA)、ゲスト物理アドレス(GPA)、または仮想アドレス(VA)になる。

両ステージで選択された仮想メモリ方式が `Bare` の場合、IOVA は SPA
となる。IOMMU によるアドレス変換や保護は行われない。

第1段階で選択された仮想メモリスキームが  `Bare`
であり、第2段階のスキームが `Bare` でない場合、IOVA は GPA(Guest
Physical Address)
となる。ファーストステージは事実上無効となる。セカンドステージはGPAをSPAに変換し、設定されたメモリ保護を実行する。このような構成は、デバイス制御が仮想マシンに渡されるが、VM
内のゲスト OS
が第1段階のアドレス変換を使用せず、そのようなデバイスからのメモリ・アクセスをさらに制約する場合に一般的に採用される。RISC-V
HARTと比較すると、この構成は、 RISC-V
HARTでGステージがアクティブでVSステージがベアに設定された2ステージのアドレス変換が有効であることと類似している。

ファーストステージで選択された仮想メモリスキームが `Bare` ではなく、セカンドステージのスキームが
 `Bare` の場合、IOVAはVAとなる。セカンドステージは事実上無効となる。ファーストステージはVAをSPA
に変換し、設定されたメモリ保護を実行する。この構成は、IOMMU がネイティブ
OS によって使用され
る場合、またはデバイスの制御がハイパーバイザ自身によって保持される場合に通常採用される。RISC-V
HARTと比較すると、この構成は、RISC-V
HARTでシングルステージアドレス変換が有効であることと類似している。

どちらのステージでも選択された仮想メモリ方式ががどちらもBareでない場合、IOVAはVAとなる。2
段階のアドレス変換 が有効である。第 1 段階は VA を GPA に変換し、第 2
段階は GPA を SPA に変換する。各ステージは、設
定されたメモリ保護を実施する。このような構成は、デバイス制御が仮想マシンにパススルーされ、VM
のゲストOSが第1段階のアドレス変換を使用して、そのようなデバイスによってアクセスされるメモリと
関連する特権およびメモリ保護をさらに制約する場合に一般的に採用される。RISC-V
HARTと比較すると
、この構成は、GステージとVSステージの両方がアクティブなRISC-V
HARTで、2ステージのアドレス変換が有効であることに類似している( `Bare` ではないことに注意)。

IOMMUにおけるDMAアドレス変換は、ソフトウェアが提供するデータ構造を使用してSPAを決定するの
に必要な時間によってアクセス時間が長くなる可能性があるため、DMAアクセスに一定のパフォーマンス上の影響がある。CPUのMMUにおける同様のオーバーヘッドは、通常、アドレス変換をキャッシュす
るTLB(Translation Look-aside
Buffer)を使用することで軽減される。IOMMUは、IOMMUアドレス変換キャッシュ(IOATC)と呼ばれる同様のアドレス変換キャッシュを採用することができる。IOMMUは
、アドレス変換に使用されるメモリ常駐データ構造が変更されたときに、ソフトウェアがIOATCを同期させるメカニズムを提供する。ソフトウェアは、ゲスト・ソフトコンテキスト識別子(GSCID)と呼ばれるソフトウェア定義コンテキスト識別子でデバイス・コンテキストを構成して、デバイスの集合が同じVMに割り当てられていることを示し、共通の仮想アドレス空間にアクセスすることができる。ソフトウェアは
、共通の仮想アドレス空間を共有するプロセスの集合を識別するために、プロセスソフトコンテキスト識
別子(PSCID)と呼ばれるソフトウェア定義コンテキスト識別子でプロセスコンテキストを構成してもよい
。IOMMU は、GSCID と PSCID を使用して IOATC
のエントリをタグ付けし、重複を回避して無効化操作を
簡素化することができる。

デバイスによっては、変換プロセスに参加し、自身のメモリ・アクセス用にデバイス側
ATC(DevATC)を提供するものもある。DevATCを提供することで、デバイスはトランスレーション・キャッシングの責任を共有し、それによってIOATCにおける「スラッシング」の確率を減らすことができる。DevATCは、そのデバイス独自の性能要件に合わせてサイズを決めることができ、また、変換をプリフェッチすることによってDMAレイテンシを最適化するためにデバイスが使用することもできる。このようなメカニズムには、プロトコルを使用したデバイスとIOMMUの密接な協力が必要である。例えばPCIeの場合、Address
Translation
Services(ATS)プロトコルは、デバイスがDevATC内のキャッシュに変換を要求し、ソフトウェア・アドレス変換データ構造による更新と同期させるために使用されます。デバイスがアドレス変換プロセスに参加することで、I/Oページフォールトの使用も可能になり、コアカーネルメモリマネージャがデバイスによってアクセスされる可能性のあるすべての物理メモリを常に常駐させる必要がなくなります。例えば
PCIe
の場合、デバイスはページ要求インターフェイス(PRI)を実装して、変換を要求したページが利用可能でないことが判明した場合に、メモリマネージャにページを常駐させるよう動的に要求することができます。IOMMU
は、PCIe ATS や PCIe PRI
[1]などのサービスを実現するために、デバイスとの特別なソフトウェア・インターフェイスやプロトコルをサポートする場合があります。

IMSIC (Incoming Message-Signaled Interrupt Controller)
で構築されたシステムでは、IOMMU はハイパーバイザによって、ゲスト OS
によって制御されるデバイスからのメッセージシグナル割り込み (MSI) を
IMSIC
内のゲスト割り込みファイルに向けるようにプログラムされることがある。デバイス
からの MSI は単なるメモリ書き込みであるため、IOMMU
が他のメモリ書き込みに適用するのと同じアドレス変換が当然適用される。しかし、RISC-V
Advanced Interrupt Architecture
[2]では、ソフトウェアを簡素化するためと、メモリ常駐割り込みファイルをオプションでサポートするために、IOMMUが仮想マシンに向けたMSIを特別に扱うことを要求している。デバイス・コンテキストは、仮想割り込みファイルへのメモリ・アクセスを識別し、デバイス・コンテキスト内でソフトウェアによって設定された
MSIアドレス変換テーブルを使用して変換されるパラメータでソフトウェアによって設定される。

=== 1.2. 使用モデル

非仮想化OSは、以下の重要なシステムレベル機能にIOMMUを使用することができる：

[arabic]
. 誤動作デバイスからの不正なメモリアクセスからオペレーティングシステムを保護する。
. 64ビット環境で32ビットデバイスをサポート(バウンスバッファの回避)
. 断片化された物理アドレスへの連続した仮想アドレスのマッピングをサポート(スキャッター/ギャザ
ーリストの回避)
. 共有仮想アドレッシングのサポート

IOMMUがない場合、デバイスは特権メモリなどのあらゆるメモリにアクセスし、悪意のある、あるいは
意図しない破損を引き起こす可能性がある。これは、ハードウェアのバグ、デバイス・ドライバのバグ、
あるいは悪意のあるソフトウェアやハードウェアによるものかもしれない。

IOMMUは、デバイスがアクセスできるメモリを制限することで、OSがこのような意図しない破損を防御
するメカニズムを提供する。図1に示されているように、OSはIOVAを変換するページ・テーブルで
IOMMUを構成し、それによってアクセス可能なアドレスをページ・テーブルで許可されたものに制限することができる。

.非仮想化OSにおけるデバイスの分離
image::../riscv-iommu/src/images/non-virt-OS.svg[align="center"]

レガシー32ビット・デバイスは、4GiB以上のメモリにアクセスできない。IOMMUは、そのアドレス再マッピング機能により、デバイスが(適切なアクセス許可があれば)システム内の任意のアドレスに直接アクセスできるシンプルなメカニズムを提供する。IOMMUがなければ、OSは4GiB以下のメモリに割り当てられたバッファ(バウンス・バッファとも呼ばれる)を使ってデータをコピーするしかない。このシナリオでは、IOMMUがシステム・パフォーマンスを向上させる。

IOMMUは、すべてのメモリが連続している必要なく、I/O用にメモリの大領域を割り当てることができるので、散在/収集DMAを実行するのに便利である。連続した仮想アドレス範囲は、そのような断片化された物理アドレスと、その仮想アドレス範囲でプログラムされたデバイスにマッピングすることができる。

IOMMUは、デバイスとプロセスアドレス空間を共有する機能である共有仮想アドレッシングをサポートするために使用することができる。DMAに使用される仮想アドレスは、IOMMUによってSPAに変換される。

IOMMUを非仮想化OSで使用する場合、必要なアドレス変換と保護機能はファーストステージで十分であり、セカンドステージはBareに設定することができる。

==== 1.2.2. ハイパーバイザ

IOMMUは、仮想マシンで動作するゲストオペレーティングシステムが、ハイパーバイザーの介入を最小限に抑えながら、I/Oデバイスを直接制御できるようにする。

デバイスを直接制御するゲストOS
は、ゲスト物理アドレスでデバイスをプログラムする。デバイスがこれらのアドレスを使用してメモリアクセスを実行するとき、IOMMU
は、ハイパーバイザが提供するアドレス変換データ構造を参照しながら、これらのゲスト物理アドレスをスーパーバイザ物理アドレスに変換する責任を負う。

図2はその概念を示している。デバイスD1はVM-1に直接割り当てられ、デバイスD2はVM-2に直接割り当てられている。VMMは、各デバイスに使用する第2ステージのページ・テーブルを設定し、D1がアクセスできるメモリをVM-1関連メモリに、D2がアクセスできるメモリをVM-2関連メモリに制限する。

.直接デバイス割り当てを可能にするDMA変換
image::../riscv-iommu/src/images/hypervisor.svg[align="center"]

ゲスト OS が制御するデバイスからの MSI
を処理するために、ハイパーバイザは IOMMU を構成して、それらのMSIを IMSIC
内のゲスト割り込みファイル(図 3
を参照)またはメモリ常駐割り込みファイルにリダイレクトします。IOMMUは、ハイパーバイザが提供する
MSIアドレス変換データ構造を使用して
MSIのリダイレクトを実行する責任を負います。すべての割り込みファイルは、実ファイルであれ仮想ファイルであれ、自然にアライメントされた4KiBページのアドレス空間を占有するため、必要なアドレス変換は、通常のRISC-Vページベースのアドレス変換でサポートされているのと同じ、仮想(ゲスト)ページ
アドレスから物理ページアドレスへのアドレス変換です。

.ゲストがプログラムしたMSIをIMSICゲスト割り込みファイルに直接変換するためのMSIアドレス変換
image::../riscv-iommu/src/images/msi-imsic.svg[align="center"]

==== 1.2.3. ゲストOS

ハイパーバイザは、ハードウェア・エミュレーションを通じて、あるいはハイパーバイザとのソフトウェア・インターフェース(パラ仮想化とも呼ばれる)を使用するようにゲストOSを啓発することによって、仮想IOMMU機能を提供することができる。ゲストOSは、仮想IOMMUによって提供される機能を使用して、自身が制御する第1ステージのページテーブルを使用することで、非仮想化OSについて説明したのと同じ利点を利用することができる。ハイパーバイザは、仮想マシンのアドレス空間を仮想化し、
VMに渡されたデバイスからVMに関連するメモリへのメモリアクセスを格納するために、制御する第2ステージのページテーブルを確立する。

2段階のアドレス変換が有効な場合、ゲストOSが管理する第1段階のページテーブルを使用してIOVAが最初にGPAに変換され、ハイパーバイザーが管理する第2段階のページテーブルを使用してGPAがSPAに変換される。

Figure.4 はそのコンセプトを示している。

image::../riscv-iommu/src/images/guest-OS.svg[align="center"]

IOMMUは、デバイスD1に対して第1段および第2段のページテーブルを使用してアドレス変換を実行するように構成される。第2ステージは通常、ハイパーバイザによって使用され、GPAをSPAに変換し、デバイスD1をVM-1に関連するメモリに制限します。第1ステージは通常、ゲストOSによって構成され、VAをGPAに変換し、デバイスD1のアクセスをVM-1メモリのサブセットに含めます。

デバイスD2ではセカンドステージのみがアクティブで、ファーストステージは `Bare` に設定されている。

ホストOSやハイパーバイザーは、D3のようなデバイスを保持することもできる。デバイスD3に必要なアドレス変換と保護機能はファーストステージで十分であり、セカンドステージは `Bare` に設定される。

=== 1.3. 配置とデータの流れ

image::../riscv-iommu/src/images/placement.svg[align="center"]

図5は、RISC-V HARTを搭載した典型的なSOC(SystemonaChip)の例である。
このSOCには、メモリ・コントローラと複数のIOデバイスが組み込まれている。
このSOCには、IOMMUの2つのインスタンスも組み込まれている。
デバイスはIOブリッジとシステム・インターコネクトに直接接続されるか、IOプロトコル・トランザクションからシステム・インターコネクト・トランザクションへの変換が必要な場合はルート・ポートを介して接続される。
例えば、PCIe[1]の場合、ルート・ポートは、関連する仮想PCI-PCIブリッジを介して階層の一部をマッピングし、PCIeIOプロトコル・トランザクションをシステム・インターコネクト・トランザクションにマッピングするPCIeポートである。

最初のIOMMUインスタンスであるIOMMU 0(IO Bridge 0に関連)は、Root
Portをシステムファブリック/インターコネクトにインターフェイスする。1つまたは複数のエンドポイント・デバイスは、このルートポートを介してSoCにインターフェースされる。PCIeの場合、ルート・ポートには、IOMMUがPCIe
ATSプロトコルをサポートするために使用されるIOMMUへのATSインターフェイスが組み込まれている。この例では、PCIe
ATSプロトコル[1]を使用してデバイスがIOMMU
0から取得したトランスレーションを保持するデバイス側ATC(DevATC)を持つエンドポイントデバイスを示している。

1つめのIOMMUインスタンスであるIOMMU 0(IO Bridge
0に関連している)は、ルート・ポートをシステムファブリック・インターコネクトに対して接続する。つまり、1つ以上のエンドポイント・デバイスが、このルート・ポートを介してSoCに接続される。PCIeの場合、ルート・ポートには、IOMMUがPCIe
ATSプロトコルをサポートするためにATSインタフェースが接続されている。これはIOMMUに接続されている。PCIe
ATSプロトコル[1]を使用してデバイスがIOMMU
0から取得した変換を保持するために、デバイス側のエンドポイントにDevice
ATS(DevATC)を保持している。

ルートポートを使用したIOプロトコルからシステム・ファブリック・プロトコルへの変換が必要ない場合、デバイスはシステム・ファブリックと直接インターフェイスすることができる。第2のIOMMUインスタンスであるIOMMU
1(IOブリッジ1に接続)は、ルートポートを使用せずに、デバイス(IOデバイスAおよびB)をシステムファブリックにインターフェイスする様子を示している。

IOデバイスは、IO仮想アドレス(VA, GVA,
GPA)を使用してDMAトランザクションを実行できる。IO
Bridgeは関連するIOMMUを呼び出して、IOVAをSupervisor Physical
Addresses(SPA)に変換する。

IOMMUはアウトバウンドトランザクションには呼び出されない。

IOMMUは、受信トランザクションのアドレス変換と保護のためにIOブリッジによって呼び出される。インバウンド・トランザクションに関連するデータは、IOMMUでは処理されない。IOMMUはIOブリッジに対するルックアサイドIPのように動作し、いくつかのインターフェイスを持つ(図6参照)：

image::../riscv-iommu/src/images/interfaces.svg[../riscv-iommu/src/images/interfaces]

* ホスト・インタフェース：IOMMUのメモリ・マップされたレジスタにアクセスし、グローバル・コンフィギュレーションやメンテナンスを実行するためのインタフェース。
* Device translation Request インタフェース： IO Bridge
から変換リクエストを受け取るインタフェースである。このインタフェースで
IO Bridge はリクエストに関する以下のような情報を提供する：
[loweralpha]
. トランザクションに関連付けられたハードウェア ID -
 `device_id` 、および必要に応じて `process_id` とそのvalidity。
IOMMUは、要求されたアドレス変換を実行するためのコンテキスト情報を取得するために、ハードウェアID
を使用する。
. IOVA とトランザクションの種類(変換済みまたは未変換)。
. リクエストが読み取り、書き込み、実行、またはアトミック操作のどれであるか。
+
​i.
実行リクエストは、リクエストに明示的に関連付けられなければならない(例:
PCIe
PASIDを使用)明示的に要求されていない場合、デフォルトは0でなければならない。
[loweralpha, start=4]
. リクエストに関連付けられた特権モード。特権モードがリクエストに明示的に関連付けられていない場合(例:
PCIe
PASIDを使用している場合)、デフォルトの特権モードはUserでなければならない。 `process_id` がないリクエストの場合、特権モードはUserでなければならない。
. リクエストによってアクセスされたバイト数。
. IO Bridge はまた、IOMMU によって解釈されないが、IOMMU から IO Bridge
への応答と一緒に返される、追加の不透明な情報(例えばタグ)を提供することができる。IOMMU
は変換要求を順番通りに返さなくても良いことがため、このような情報は IO
Bridge が以前の要求と完了を関連付けるために使用することができる。
* Data
Structureインタフェース：IOMMUがメモリへの暗黙のアクセスに使用する。これはIOブリッジへのリクエスタインタフェースであり、メインメモリから必要なデータ構造をフェッチするために使用される。このインタフェースは以下のアクセスに使用される：
** {blank}
[loweralpha]
. コンテキスト情報と変換ルールを取得するためのデバイスとプロセスのディレクトリ。
** {blank}
[loweralpha, start=2]
. IOVAを変換するための第一段および/または第二段のページテーブルエントリ。
** {blank}
[loweralpha, start=3]
. ソフトウェアとのインタフェースに使用されるメモリ内キュー(コマンドキュー、フォールトキュー、ページリクエストキュー)。
* Data Translation
Completienインタフェース：以前に要求されたアドレス変換に対するIOMMUからの完了応答を提供するインタフェースである。完了インタフェースは以下のような情報を提供する：
** {blank}
[loweralpha]
. リクエストが正常に完了したか、あるいはフォルトが発生したかを示す、リクエストのステータス。
** {blank}
[loweralpha, start=2]
. リクエストが正常に完了した場合、SPA(Supervisor Physical Address)。
** {blank}
[loweralpha, start=3]
. リクエストに関連する不透明な情報(タグなど)(該当する場合)。
** {blank}
[loweralpha, start=4]
. Svpbmtがサポートされている場合、IOMMUアドレス変換ページテーブルから得られるページベースのメモリタイプ(PBMT)。IOMMUは、第1ステージのページテーブルエントリと第2ステージのページテーブルエントリの間で解決されたページベースのメモリタイプを提供する。
* ATSインタフェース：ATSインタフェースは、オプションのPCIeATS機能がIOMMUでサポートされている場合、PCIeルートポートを介してATS対応エンドポイントと通信するために使用されます。このインタフェースが使用される：
** {blank}
[loweralpha]
. エンドポイントからATS変換要求を受信し、エンドポイントに完了を返す。ルートポートは、要求を発信したエンドポイントがCXLタイプ1またはタイプ2のデバイスであるかどうかの表示を提供することができる。
** {blank}
[loweralpha, start=2]
. ATS「無効化要求」メッセージをエンドポイントに送信し、エンドポイントから「無効化完了」メッセージを受信する。
** {blank}
[loweralpha, start=3]
. エンドポイントから「ページ要求」と「停止マーカー」メッセージを受信し、エンドポイントに「ページ要求グループ応答」メッセージを送信する。

メモリ常駐割り込みファイル(MRIF)(RISC-V Advanced Interrupt
Architecture[2]
参照)に着信MSIを記録するインタフェースは、実装固有のものである。着信MSIをMRIFに記録し、関連する通知MSIを生成するためのIOMMUとIOブリッジ間の責任分担は、実装に固有である。

RISC-V
HARTと同様に、物理メモリ属性(PMA)と物理メモリ保護(PMP)チェックは、IOMMUがバイパス(ベア・モード)であっても、すべてのインバウンドIOトランザクションで完了しなければならない。PMAおよびPMPチェッカーの配置と統合は、プラットフォームの選択による。PMAおよびPMPチェッカーはIOMMUの外部に存在する。上の例では、IO
Bridgeにある。IOMMU自身によるデータ構造インタフェースを介した暗黙のアクセスはPMAチェッカーによってチェックされる。PMAは物理プラットフォームの構成と密接に結びついており、多くの詳細は本質的にプラットフォーム固有である。IOMMUがデータ構造インタフェースを使用して実行するメモリ・アクセスは、一般に、デバイス主導のメモリ・アクセスと順序付ける必要はない。1

[NOTE]
====
IOMMUは、アドレス変換を実行するために必要なデータ構造にアクセスするために、データ構造インタフェース上で暗黙のメモリ・アクセスを生成することがある。
このようなアクセスは、元のデバイス主導のメモリ・アクセスによってブロックされてはならない。
====

IOブリッジは、IOブリッジとシステムインターコネクトによって定義された必要なハザードチェックと他のルールを満たすために、データ構造インターフェイス上でメモリアクセスの順序付けを実行することができる。

IOMMUは、解決されたPBMT(Page Base Memory Type):
(PMA、IO、NC)を、デバイス変換完了インターフェース上の変換されたアドレスとともにIOブリッジに提供する。IO
BridgeのPMAチェッカーは、提供されたPBMTを使用して、関連するメモリページのPMAを上書きすることができる。

PMPチェッカは、バス・アクセス・イニシエータのハードウェアIDを使用して、物理メモリ・アクセス権限を決定することができる。IOMMU自身が暗黙のアクセスのためのバスアクセスイニシエータであるため、IOMMUハードウェアIDは、PMPチェッカが適切なアクセス制御ルールを選択するために使用してもよい。

[NOTE]
====
IOMMU は、IO ブリッジが提供するハードウェア ID の真正性を検証しない。
IOブリッジおよび/またはルートポートは、ハードウェア IDを認証するための適切なメカニズムを 含まなければならない。
SOCによっては、これはデバイスがSOCに統合され、そのIDが不変であるという特性、例えばPCIeの場合、ハードウェアIDを認証するために、PCIeで定義されたアクセス制御サービス(ACS)のソース検証機能を使用することができる。
IOブリッジの他の実装固有のメソッドが、このような認証を実行するために提供されてもよい。
====

=== 1.4. IOMMUの特徴

RISC-V IOMMU仕様のバージョン1.0は、以下の機能をサポートしている：

* メモリ・ベースのデバイス・コンテキストで、パラメータとアドレス変換構造を見つける。デバイス・コンテキストは、ハードウェアが提供する一意の `device_id` を使用して配置される。サポートされる `device_id` の幅は24ビットまでである。
* ハードウェアが提供する一意の `process_id` を使用して、パラメータとアドレス変換構造を見つけるための、メモリベースのプロセスコンテキスト。サポートされる `process_id` は最大20ビットである。
* 16ビットのGSCIDと20ビットのPSCID。
* 2段階のアドレス変換。
* RISC-V Privileged仕様[3]で規定されているページベースの仮想メモリシステムにより、CPU MMUとIOMMUに共通のページテーブルを使用するか、IOMMUに個別のページテーブルを使用するかをソフトウェアが柔軟に選択できる。
* 最大57ビットの仮想アドレス幅、56ビットのシステム物理アドレス幅、59ビットのゲスト物理アドレス幅。
* PTE アクセス済みビットとダーティビットのハードウェア更新。
* RISC-V Advanced Interrupt Architecture [2]で規定されたMSIページテーブルを使用して、仮想割り込みファイルへのメモリアクセスとMSIアドレス変換を識別する。
* Svnapot と Svpbmt 拡張。
* PCIe ATS および PRI サービス [1]。翻訳要求に応答して、SPA ではなく GPA に IOVA を翻訳することをサポートする。
* ハードウェア・パフォーマンス・モニター(HPM)。
* ソフトウェアにサービスを要求するためのMSIおよびワイヤシグナル割り込み。
* ソフトウェアがデバッグをサポートするためにアドレス変換を要求するためのレジスタ・インターフェース。

IOMMUがサポートする機能は、5.3節のcapabilitiesレジスタを使用して検出することができる。
